---
phase: 04-human-loop
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - requirements.txt
  - src/execution/remediation.py
  - src/azure/compute.py
  - src/web/app.py
  - tests/test_remediation_execution_gate.py
autonomous: true
user_setup:
  - service: azure
    why: "Execute remediation actions (stop VM, configure auto-shutdown)"
    env_vars:
      - name: AZURE_SUBSCRIPTION_ID
        source: "Azure Portal -> Subscriptions"
    dashboard_config:
      - task: "Grant principal Contributor on target resource group (demo only)"
        location: "Azure Portal -> Resource Group -> Access control (IAM)"

must_haves:
  truths:
    - "No remediation executes unless an approval decision is recorded"
    - "Approved remediation triggers an execution attempt and records outcome"
  artifacts:
    - path: "src/execution/remediation.py"
      provides: "Remediation executor with approval gate"
    - path: "src/azure/compute.py"
      provides: "VM stop/auto-shutdown helpers"
  key_links:
    - from: "src/web/app.py"
      to: "src/execution/remediation.py"
      via: "on approval"
      pattern: "execute_remediation"
---

<objective>
Implement remediation execution with a strict approval gate.

Purpose: Meet HUMAN-04: execute fixes only after human approval.
Output: Remediation executor, minimal Azure Compute helper, wiring from Slack approval to execution.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/04-human-loop/04-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Azure Compute helper wrapper (stop VM + auto-shutdown placeholder)</name>
  <files>requirements.txt, src/azure/compute.py</files>
  <action>
Create `src/azure/compute.py`:
- Add `azure-mgmt-compute` to `requirements.txt`.
- Implement `stop_vm(credential, subscription_id, resource_group, vm_name)` using `ComputeManagementClient` and `virtual_machines.begin_power_off(...)`.
- For `add_auto_shutdown(...)`, implement as a placeholder that returns a clear "not implemented" or calls Azure REST if known; keep it isolated.
If the auto-shutdown API is uncertain, implement `add_auto_shutdown` as a no-op with `status=degraded` execution result (so demo can still succeed with stop_vm).
  </action>
  <verify>. .venv/bin/activate && pip install -r requirements.txt -r requirements-dev.txt && PYTHONPATH=src python3 -c "from azure.compute import stop_vm; print('ok')"</verify>
  <done>Compute helper module exists and provides a callable stop_vm function.</done>
</task>

<task type="auto">
  <name>Task 2: Implement remediation executor with approval gate</name>
  <files>src/execution/remediation.py, tests/test_remediation_execution_gate.py</files>
  <action>
Create `src/execution/remediation.py`:
- `ExecutionOutcome`: `action`, `status`, `message`, `started_at`, `finished_at`.
- `execute_remediation(plan, approval_record) -> list[ExecutionOutcome]`:
  - If approval is not `approve`, return outcomes with `status=skipped`.
  - If approved, execute supported actions (start with `stop_vm`).
  - Catch exceptions and return `status=error` with message.

Add `tests/test_remediation_execution_gate.py`:
- Ensure `reject` results in `skipped` without executing
- Ensure `approve` attempts execution (mock compute calls)
  </action>
  <verify>. .venv/bin/activate && PYTHONPATH=src pytest -q</verify>
  <done>Executor enforces approval gate and has unit tests proving skip vs execute behavior.</done>
</task>

<task type="auto">
  <name>Task 3: Wire Slack approval endpoint to remediation execution</name>
  <files>src/web/app.py, src/integrations/slack.py</files>
  <action>
Update `POST /webhooks/slack/actions`:
- When decision == approve, locate the latest remediation plan for that investigation id (store it in memory alongside report when generated).
- Call `execute_remediation` and post a follow-up Slack webhook message summarizing outcomes.
Do not block the HTTP response on long execution; if needed, trigger execution in a background task.
  </action>
  <verify>. .venv/bin/activate && PYTHONPATH=src pytest -q</verify>
  <done>Approving in Slack triggers an execution attempt and sends a follow-up message (or logs) with results.</done>
</task>

</tasks>

<verification>
- `pytest` passes
- (If Slack + Azure configured) approve a remediation and see execution attempt + Slack follow-up
</verification>

<success_criteria>
- HUMAN-04 met for at least one action type (stop VM) with approval gating
</success_criteria>

<output>
After completion, create `.planning/phases/04-human-loop/04-03-SUMMARY.md`
</output>
