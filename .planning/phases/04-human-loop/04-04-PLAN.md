---
phase: 04-human-loop
plan: 04
type: execute
wave: 4
depends_on: ["04-03"]
files_modified:
  - src/web/app.py
  - src/web/settings.py
  - src/agents/coordinator.py
  - tests/test_alert_payload_parsing.py
autonomous: true

must_haves:
  truths:
    - "System can accept a realistic Azure Monitor webhook payload"
    - "Coordinator extracts alert identifiers and key context deterministically"
  artifacts:
    - path: "src/web/app.py"
      provides: "Webhook handler for Azure Monitor payload"
  key_links:
    - from: "src/web/app.py"
      to: "src/agents/coordinator.py"
      via: "alert parsing -> handle_alert"
      pattern: "handle_alert"
---

<objective>
Harden the webhook intake: parse realistic Azure Monitor alert payloads and improve reliability (timeouts, retries, idempotency keys).

Purpose: Make the demo flow resilient and closer to a real alert trigger.
Output: Better alert parsing, basic idempotency, and tests using fixture payloads.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/04-human-loop/04-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add alert payload normalization (Azure Monitor common schema)</name>
  <files>src/web/app.py, src/agents/coordinator.py</files>
  <action>
Implement an alert normalization function (in `src/web/app.py` or a small helper module):
- Accept either the simple JSON used so far or Azure Monitor common alert schema payload.
- Extract stable fields: `alert_id`, `rule_name`, `severity`, `fired_date_time`, `resource_id` (if present).

Update coordinator to accept a normalized payload shape and store `investigation_id = alert_id` consistently.
  </action>
  <verify>. .venv/bin/activate && PYTHONPATH=src python3 -c "from agents.coordinator import CoordinatorAgent; print('ok')"</verify>
  <done>Coordinator can take a realistic payload and always derive an investigation id.</done>
</task>

<task type="auto">
  <name>Task 2: Add idempotency + basic retry policy</name>
  <files>src/web/app.py, src/web/settings.py</files>
  <action>
Add to settings:
- `IDEMPOTENCY_TTL_SECONDS` default 600
- `MAX_AGENT_RETRIES` default 1

In webhook handler:
- If investigation_id already processed within TTL, return cached report.
- For agent runs that return `status=error`, retry once if error appears transient (timeout/network).
Keep state in-memory (dict with timestamps) for demo; do not introduce external cache.
  </action>
  <verify>. .venv/bin/activate && PYTHONPATH=src pytest -q</verify>
  <done>Duplicate webhooks within TTL return the same report and do not re-execute the pipeline.</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for realistic alert payload parsing</name>
  <files>tests/test_alert_payload_parsing.py</files>
  <action>
Create `tests/test_alert_payload_parsing.py`:
- Include a representative Azure Monitor alert payload fixture inline (trim to needed fields).
- POST it to `/webhooks/alert` and assert the response contains the derived investigation_id and does not error.
  </action>
  <verify>. .venv/bin/activate && PYTHONPATH=src pytest -q</verify>
  <done>Unit tests cover parsing of a realistic Azure Monitor alert payload.</done>
</task>

</tasks>

<verification>
- `pytest` passes
- Manual smoke: post a realistic payload and see Slack message + approvals flow still work
</verification>

<success_criteria>
- Phase 4 success criteria met: Slack notify + approvals + execution + realistic intake
</success_criteria>

<output>
After completion, create `.planning/phases/04-human-loop/04-04-SUMMARY.md`
</output>
