---
phase: 04-human-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/integrations/slack.py
  - src/integrations/message_format.py
  - src/web/app.py
  - tests/test_slack_formatting.py
autonomous: true
user_setup:
  - service: slack
    why: "Send human notifications"
    env_vars:
      - name: SLACK_WEBHOOK_URL
        source: "Slack -> Incoming Webhooks"

must_haves:
  truths:
    - "A completed investigation posts a readable Slack message"
    - "Slack message contains key cost, root cause, and suggested action"
  artifacts:
    - path: "src/integrations/slack.py"
      provides: "Slack webhook client"
    - path: "src/integrations/message_format.py"
      provides: "Human-readable Slack message builder"
  key_links:
    - from: "src/web/app.py"
      to: "src/integrations/slack.py"
      via: "send message after investigation"
      pattern: "send_webhook"
---

<objective>
Add Slack notification for investigation completion with a human-readable summary.

Purpose: Put the system output where humans actually look during an incident.
Output: Slack webhook client, message formatting, webhook route sends Slack notification.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-diagnosis-remediation/03-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Slack webhook client</name>
  <files>src/integrations/slack.py</files>
  <action>
Create `src/integrations/slack.py`:
- `send_webhook(text, blocks=None) -> None` using `SLACK_WEBHOOK_URL`.
- Implement via `httpx` POST to the incoming webhook URL (no additional dependencies).
- Validate env var at call time; if missing, no-op with a clear log line (do not crash the pipeline).
  </action>
  <verify>. .venv/bin/activate && PYTHONPATH=src python3 -c "from integrations.slack import send_webhook; print('ok')"</verify>
  <done>Slack client exists and can be called without crashing when env var is missing.</done>
</task>

<task type="auto">
  <name>Task 2: Create readable Slack message formatting (text + blocks)</name>
  <files>src/integrations/message_format.py, tests/test_slack_formatting.py</files>
  <action>
Create `src/integrations/message_format.py`:
- `format_investigation_report_for_slack(report) -> {text, blocks}`
- Include: top cost driver(s), confidence, root cause title, and first remediation action.

Add `tests/test_slack_formatting.py` to assert:
- formatting returns a non-empty text string
- blocks are valid JSON-serializable primitives (dict/list/str)
  </action>
  <verify>. .venv/bin/activate && PYTHONPATH=src pytest -q</verify>
  <done>Formatting is deterministic and tested.</done>
</task>

<task type="auto">
  <name>Task 3: Post Slack message after webhook-triggered investigation</name>
  <files>src/web/app.py</files>
  <action>
Update `POST /webhooks/alert`:
- After generating the full investigation report, call Slack formatter + `send_webhook`.
- Still return the JSON report in the HTTP response.
  </action>
  <verify>. .venv/bin/activate && PYTHONPATH=src pytest -q</verify>
  <done>Investigation completion triggers a Slack send attempt and does not break HTTP responses.</done>
</task>

</tasks>

<verification>
- `pytest` passes
- (If SLACK_WEBHOOK_URL configured) a test alert results in a Slack message
</verification>

<success_criteria>
- Phase 4 HUMAN-01/HUMAN-02 partial: Slack message can be sent and is human-readable
</success_criteria>

<output>
After completion, create `.planning/phases/04-human-loop/04-01-SUMMARY.md`
</output>
