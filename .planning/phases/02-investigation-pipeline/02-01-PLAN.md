---
phase: 02-investigation-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/models/findings.py
  - src/models/agent_protocol.py
  - src/storage/incident_store.py
  - src/storage/incident_search.py
  - tests/test_findings_merge.py
autonomous: true

must_haves:
  truths:
    - "All investigator agents return a consistent result envelope"
    - "Coordinator can merge multiple agent findings deterministically"
    - "Incident persistence and similarity search are split behind separate interfaces"
  artifacts:
    - path: "src/models/agent_protocol.py"
      provides: "Base protocol for agent inputs/outputs"
    - path: "src/storage/incident_store.py"
      provides: "Incident persistence interface"
    - path: "src/storage/incident_search.py"
      provides: "Incident similarity search interface"
  key_links:
    - from: "src/models/findings.py"
      to: "src/models/agent_protocol.py"
      via: "Typed envelopes"
      pattern: "AgentResult"
    - from: "src/storage/incident_store.py"
      to: "src/storage/incident_search.py"
      via: "Separated persistence vs search boundary"
      pattern: "class\\s+IncidentSearch"
---

<objective>
Introduce shared models and interfaces so Resource and History agents can plug into the same pipeline.

Purpose: Prevent later orchestration code from hardcoding per-agent return shapes.
Output: Agent protocol models, expanded findings model, incident store/search interfaces, merge logic tests.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define agent protocol models (inputs, outputs, status)</name>
  <files>src/models/agent_protocol.py</files>
  <action>
Create `src/models/agent_protocol.py`:
- `AgentName` enum: `cost`, `resource`, `history`, `diagnosis`, `remediation`
- `AgentStatus` enum: `ok`, `degraded`, `error`
- `AgentResult[T]` generic-like model (use `pydantic.BaseModel` + `typing.Any` if needed): fields `agent`, `status`, `started_at`, `finished_at`, `data`, `errors`.
- Keep it JSON-serializable and stable.
  </action>
  <verify>. .venv/bin/activate && PYTHONPATH=src python3 -c "from models.agent_protocol import AgentResult; print('ok')"</verify>
  <done>Agent protocol file exists and can represent a result with status and error info.</done>
</task>

<task type="auto">
  <name>Task 2: Expand Findings model to support multiple investigators</name>
  <files>src/models/findings.py, tests/test_findings_merge.py</files>
  <action>
Update `src/models/findings.py`:
- Add optional sections: `resource_findings`, `history_findings`.
- Add a `UnifiedFindings` model that contains:
  - the original alert payload summary
  - `results: dict[AgentName, AgentResult]`
  - helper method `merge(results: list[AgentResult]) -> UnifiedFindings` (pure, deterministic)

Add `tests/test_findings_merge.py` to assert:
- merge order does not change the output
- statuses and errors are preserved per-agent
  </action>
  <verify>. .venv/bin/activate && PYTHONPATH=src pytest -q</verify>
  <done>Unified findings model exists and merge function is covered by tests.</done>
</task>

<task type="auto">
  <name>Task 3: Add incident store + incident search interfaces (memory stubs)</name>
  <files>src/storage/incident_store.py, src/storage/incident_search.py</files>
  <action>
Create `src/storage/incident_store.py`:
- `IncidentRecord` model: `id`, `created_at`, `title`, `summary`, `root_cause`, `resolution`, `tags`, `raw`.
- `IncidentStore` interface-style class with:
  - `put(record) -> None`
  - `get(id) -> IncidentRecord | None`
  - `list_recent(limit: int = 50) -> list[IncidentRecord]` (for local fallback similarity search)
- `MemoryIncidentStore` implementation (in-memory dict) that satisfies the interface.

Create `src/storage/incident_search.py`:
- `IncidentSearch` interface-style class with: `search_similar(query: str, k: int) -> list[dict]`.
  - Return items must include at least `id` and may include `score`.
- `LocalIncidentSearch` implementation that:
  - depends on an `IncidentStore`
  - calls `store.list_recent(...)` to build a candidate set
  - does a simple, deterministic keyword overlap score
  - returns top-k hits as `{id, score}`

Rationale: Keep persistence (Cosmos) and similarity search (Azure AI Search) separate so HistoryAgent can compose both.
  </action>
  <verify>. .venv/bin/activate && PYTHONPATH=src python3 -c "from storage.incident_store import IncidentStore, MemoryIncidentStore; from storage.incident_search import IncidentSearch, LocalIncidentSearch; print('ok')"</verify>
  <done>IncidentStore/IncidentSearch interfaces exist with local fallback implementation and import without Azure configuration.</done>
</task>

</tasks>

<verification>
- `pytest` passes
- Findings merge is deterministic
</verification>

<success_criteria>
- New agents can return typed results that the coordinator can merge
</success_criteria>

<output>
After completion, create `.planning/phases/02-investigation-pipeline/02-01-SUMMARY.md`
</output>
