---
phase: 06-perfect-stack-migration
plan: 01
type: execute
wave: 1
depends_on: ["05-04"]
files_modified:
  - dotnet/Spikehound.sln
  - dotnet/src/Spikehound.Core/**
  - dotnet/src/Spikehound.Functions/**
  - dotnet/tests/Spikehound.Core.Tests/**
  - README.md
autonomous: true
must_haves:
  truths:
    - "New .NET 8 Azure Functions (isolated) app exposes /health, /webhooks/alert, /webhooks/slack/actions, /webhooks/discord/interactions"
    - "Coordinator orchestration composes cost/resource/history + diagnosis + remediation + notifications"
    - "Cloud calls are env-gated and degrade gracefully without Azure creds"
    - "Remediation execution requires explicit human approval"
    - "Core unit tests cover parsing, signature verification, and coordinator composition"
  artifacts:
    - path: dotnet/src/Spikehound.Functions
      provides: HTTP endpoints + durable orchestration host
    - path: dotnet/src/Spikehound.Core
      provides: parsing + signatures + coordinator domain logic
    - path: dotnet/tests/Spikehound.Core.Tests
      provides: unit tests (no external services)
---

<objective>
Migrate the demo surface from Python/FastAPI to the “perfect” stack:
- .NET 8 (C#)
- Azure Functions (isolated worker)
- Durable Functions for fan-out/fan-in orchestration (agents)

The hackathon demo must remain runnable locally without Azure credentials.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@README.md
@src/web/app.py
@src/integrations/slack.py
@src/integrations/discord.py
@tests/test_slack_signature.py
@tests/test_discord_interactions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold .NET solution (Core + Functions + Tests)</name>
  <files>dotnet/**</files>
  <action>
Create a new .NET solution under `dotnet/`:
- `Spikehound.sln`
- `src/Spikehound.Core` (domain + parsing + signature verification + coordinator logic)
- `src/Spikehound.Functions` (Azure Functions isolated host + HTTP endpoints + Durable orchestration stubs)
- `tests/Spikehound.Core.Tests` (xUnit)

Ensure `dotnet build` and `dotnet test` run without requiring any external services.
  </action>
  <verify>cd dotnet && /home/ubuntu/.dotnet/dotnet test</verify>
  <done>Solution exists, compiles, and tests run locally.</done>
</task>

<task type="auto">
  <name>Task 2: Port core contracts + parsing + safety models</name>
  <files>dotnet/src/Spikehound.Core/**</files>
  <action>
Implement the core contract surface mirrored from the Python demo:
- Alert normalization (from `src/web/app.py:normalize_alert_payload`)
- Agent protocol models: AgentName/AgentStatus/AgentResult
- Findings/Report models: UnifiedFindings + InvestigationReport
- Approval models and remediation plan/action models with safety invariant: remediation actions always require human approval.
  </action>
  <verify>cd dotnet && /home/ubuntu/.dotnet/dotnet test</verify>
  <done>Core contracts exist and are used by the coordinator logic.</done>
</task>

<task type="auto">
  <name>Task 3: Port Slack + Discord signature verification (+ tests)</name>
  <files>dotnet/src/Spikehound.Core/**, dotnet/tests/Spikehound.Core.Tests/**</files>
  <action>
Implement signature verification helpers equivalent to:
- Slack: `src/integrations/slack.py:verify_signature`
- Discord: `src/integrations/discord.py:verify_discord_signature`

Add unit tests equivalent to:
- `tests/test_slack_signature.py`
- `tests/test_discord_interactions.py` (signature verification cases)
  </action>
  <verify>cd dotnet && /home/ubuntu/.dotnet/dotnet test</verify>
  <done>Signature verification is deterministic, env-gated, and fully unit-tested.</done>
</task>

<task type="auto">
  <name>Task 4: Implement coordinator orchestration composition (fan-out/fan-in) (+ tests)</name>
  <files>dotnet/src/Spikehound.Core/**, dotnet/tests/Spikehound.Core.Tests/**</files>
  <action>
Implement coordinator orchestration models and composition logic:
- fan-out investigators: cost/resource/history
- fan-in merge into UnifiedFindings
- diagnosis + remediation steps
- notification step(s) as best-effort, env-gated

Ensure degraded behavior without Azure creds: agents return structured degraded AgentResults.
Add tests that validate:
- coordinator calls expected steps
- report contains results for all agents and preserves safety invariant (no auto-execution).
  </action>
  <verify>cd dotnet && /home/ubuntu/.dotnet/dotnet test</verify>
  <done>Coordinator composition is unit-tested without Durable runtime.</done>
</task>

<task type="auto">
  <name>Task 5: Implement Functions HTTP endpoints with durable orchestration stubs</name>
  <files>dotnet/src/Spikehound.Functions/**</files>
  <action>
Add Azure Functions isolated HTTP endpoints equivalent to the FastAPI demo surface:
- GET `/health`
- POST `/webhooks/alert`
- POST `/webhooks/slack/actions`
- POST `/webhooks/discord/interactions`

Endpoints should:
- use core parsing + signature verification helpers
- degrade gracefully when durable/storage is not configured (inline execution fallback)
- preserve remediation safety invariant (execution only after explicit approval)
  </action>
  <verify>cd dotnet && /home/ubuntu/.dotnet/dotnet test</verify>
  <done>Endpoints exist and compile; core tests still pass.</done>
</task>

<task type="auto">
  <name>Task 6: Update README for new stack + local run instructions</name>
  <files>README.md</files>
  <action>
Update `README.md` to prioritize the .NET Azure Functions stack:
- local prerequisites (`/home/ubuntu/.dotnet/dotnet`)
- local run steps (Functions host + optional durable backend)
- env vars for Slack/Discord signatures (optional)
- how to run tests (`cd dotnet && dotnet test`)

Keep the hackathon demo runnable without Azure credentials.
  </action>
  <verify>cd dotnet && /home/ubuntu/.dotnet/dotnet test</verify>
  <done>README accurately reflects the new primary stack.</done>
</task>

</tasks>

<verification>
- `cd dotnet && /home/ubuntu/.dotnet/dotnet test` passes
</verification>

<success_criteria>
- Equivalent HTTP demo surface exists in Functions
- Durable orchestrator models exist (fan-out/fan-in) and are testable via core composition tests
- Cloud calls are env-gated; no external services required for tests
- Remediation always requires explicit human approval
</success_criteria>

<output>
After completion, create `.planning/phases/06-perfect-stack-migration/06-01-SUMMARY.md`.
</output>
