---
phase: 03-diagnosis-remediation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/agents/remediation_agent.py
  - src/models/remediation.py
  - tests/test_remediation_suggestions.py
autonomous: true

must_haves:
  truths:
    - "Remediation Agent suggests at least one fix action based on Diagnosis"
    - "Remediation suggestions are structured and safe-by-default"
  artifacts:
    - path: "src/agents/remediation_agent.py"
      provides: "Remediation Agent implementation"
    - path: "src/models/remediation.py"
      provides: "Remediation suggestion models"
  key_links:
    - from: "src/agents/remediation_agent.py"
      to: "src/models/remediation.py"
      via: "model validation"
      pattern: "RemediationPlan"
---

<objective>
Add Remediation Agent that turns a diagnosis into structured, human-approvable fix suggestions.

Purpose: Produce actions that a human can approve in Phase 4.
Output: Remediation models + agent implementation + tests.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-investigation-pipeline/02-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define remediation models (actions, safety, approval)</name>
  <files>src/models/remediation.py</files>
  <action>
Create `src/models/remediation.py`:
- `RemediationActionType` enum (MVP): `stop_vm`, `resize_vm`, `add_auto_shutdown`, `notify_owner`, `open_ticket`.
- `RemediationAction`: `type`, `target_resource_id`, `parameters` (dict), `risk_level` (low/medium/high), `human_approval_required` (always true for now).
- `RemediationPlan`: `summary`, `actions: list[RemediationAction]`, `rollback_notes`.
Validation: actions list non-empty.
  </action>
  <verify>. .venv/bin/activate && PYTHONPATH=src python3 -c "from models.remediation import RemediationPlan; print('ok')"</verify>
  <done>Remediation models exist, validate, and are JSON serializable.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Remediation Agent (Diagnosis -> RemediationPlan)</name>
  <files>src/agents/remediation_agent.py</files>
  <action>
Create `src/agents/remediation_agent.py`:
- `RemediationAgent.run(unified_findings, diagnosis) -> AgentResult`.
- Prefer deterministic rules first for the demo scenario:
  - If diagnosis mentions "GPU VM" and "no shutdown" -> suggest `add_auto_shutdown`
  - If VM running unexpectedly -> suggest `stop_vm`
- Optionally use LLM when configured (reuse FoundryClient) to generate better action parameters; but keep a rule-based fallback.
Return a RemediationPlan in `data`.
  </action>
  <verify>. .venv/bin/activate && PYTHONPATH=src python3 -c "from agents.remediation_agent import RemediationAgent; print('ok')"</verify>
  <done>Remediation Agent exists and returns an AgentResult whose data matches RemediationPlan.</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for remediation suggestion behavior</name>
  <files>tests/test_remediation_suggestions.py</files>
  <action>
Create `tests/test_remediation_suggestions.py`:
- Provide a minimal Diagnosis object for the demo scenario.
- Assert RemediationAgent returns at least one action and that `human_approval_required` is true.
  </action>
  <verify>. .venv/bin/activate && PYTHONPATH=src pytest -q</verify>
  <done>Tests validate remediation suggestions are non-empty and safe-by-default.</done>
</task>

</tasks>

<verification>
- `pytest` passes
</verification>

<success_criteria>
- Remediation suggestions exist as structured objects ready for Slack approval flow
</success_criteria>

<output>
After completion, create `.planning/phases/03-diagnosis-remediation/03-02-SUMMARY.md`
</output>
